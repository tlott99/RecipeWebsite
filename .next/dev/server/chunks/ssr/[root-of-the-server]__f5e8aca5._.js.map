{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 26, "column": 0}, "map": {"version":3,"sources":["file:///C:/Git/Senior%20Project/RecipeWebsite/src/generated/prisma/internal/class.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * WARNING: This is an internal file that is subject to change!\n *\n * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘\n *\n * Please import the `PrismaClient` class from the `client.ts` file instead.\n */\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport type * as Prisma from \"./prismaNamespace\"\n\n\nconst config: runtime.GetPrismaClientConfig = {\n  \"previewFeatures\": [],\n  \"clientVersion\": \"7.3.0\",\n  \"engineVersion\": \"9d6ad21cbbceab97458517b147a6a09ff43aa735\",\n  \"activeProvider\": \"postgresql\",\n  \"inlineSchema\": \"generator client {\\n  provider = \\\"prisma-client\\\"\\n  output   = \\\"../src/generated/prisma\\\"\\n}\\n\\ndatasource db {\\n  provider = \\\"postgresql\\\"\\n  schemas  = [\\\"neon_auth\\\", \\\"public\\\", \\\"recipe_management\\\"]\\n}\\n\\nmodel all_ingredients {\\n  id                 Int                  @id @default(autoincrement())\\n  created_at         DateTime?            @db.Timestamp(6)\\n  name               String?\\n  type               ingredient_type?\\n  recipe_ingredients recipe_ingredients[]\\n\\n  @@schema(\\\"recipe_management\\\")\\n}\\n\\nmodel instructions {\\n  id                 Int       @id @default(autoincrement())\\n  created_at         DateTime? @db.Timestamp(6)\\n  recipe_id          Int?\\n  instruction_number Decimal?  @db.Decimal\\n  instruction_text   String?\\n  recipes            recipes?  @relation(fields: [recipe_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: \\\"fk_recipe\\\")\\n\\n  @@schema(\\\"recipe_management\\\")\\n}\\n\\nmodel recipe_ingredients {\\n  id               Int               @id @default(autoincrement())\\n  created_at       DateTime?         @db.Timestamp(6)\\n  ingredient_id    Int?\\n  amount           Decimal?          @db.Decimal\\n  recipe_id        Int?\\n  measurement_type measurement_type?\\n  partial_amount   fractions?\\n  all_ingredients  all_ingredients?  @relation(fields: [ingredient_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: \\\"fk_all_ing\\\")\\n  recipes          recipes?          @relation(fields: [recipe_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: \\\"fk_recipe_ing\\\")\\n\\n  @@schema(\\\"recipe_management\\\")\\n}\\n\\nmodel recipes {\\n  id                 Int                  @id @default(autoincrement())\\n  created_at         DateTime?            @db.Timestamp(6)\\n  title              String?\\n  meal_type          meal_type?\\n  cook_time          cook_time?\\n  prep_time          prep_time?\\n  owner_id           Int?\\n  instructions       instructions[]\\n  recipe_ingredients recipe_ingredients[]\\n\\n  @@schema(\\\"recipe_management\\\")\\n}\\n\\nmodel account {\\n  id                    String    @id @default(dbgenerated(\\\"gen_random_uuid()\\\")) @db.Uuid\\n  accountId             String\\n  providerId            String\\n  userId                String    @db.Uuid\\n  accessToken           String?\\n  refreshToken          String?\\n  idToken               String?\\n  accessTokenExpiresAt  DateTime? @db.Timestamptz(6)\\n  refreshTokenExpiresAt DateTime? @db.Timestamptz(6)\\n  scope                 String?\\n  password              String?\\n  createdAt             DateTime  @default(now()) @db.Timestamptz(6)\\n  updatedAt             DateTime  @db.Timestamptz(6)\\n  user                  user      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)\\n\\n  @@index([userId])\\n  @@schema(\\\"neon_auth\\\")\\n}\\n\\nmodel invitation {\\n  id             String       @id @default(dbgenerated(\\\"gen_random_uuid()\\\")) @db.Uuid\\n  organizationId String       @db.Uuid\\n  email          String\\n  role           String?\\n  status         String\\n  expiresAt      DateTime     @db.Timestamptz(6)\\n  createdAt      DateTime     @default(now()) @db.Timestamptz(6)\\n  inviterId      String       @db.Uuid\\n  user           user         @relation(fields: [inviterId], references: [id], onDelete: Cascade, onUpdate: NoAction)\\n  organization   organization @relation(fields: [organizationId], references: [id], onDelete: Cascade, onUpdate: NoAction)\\n\\n  @@index([email])\\n  @@index([organizationId])\\n  @@schema(\\\"neon_auth\\\")\\n}\\n\\nmodel jwks {\\n  id         String    @id @default(dbgenerated(\\\"gen_random_uuid()\\\")) @db.Uuid\\n  publicKey  String\\n  privateKey String\\n  createdAt  DateTime  @db.Timestamptz(6)\\n  expiresAt  DateTime? @db.Timestamptz(6)\\n\\n  @@schema(\\\"neon_auth\\\")\\n}\\n\\nmodel member {\\n  id             String       @id @default(dbgenerated(\\\"gen_random_uuid()\\\")) @db.Uuid\\n  organizationId String       @db.Uuid\\n  userId         String       @db.Uuid\\n  role           String\\n  createdAt      DateTime     @db.Timestamptz(6)\\n  organization   organization @relation(fields: [organizationId], references: [id], onDelete: Cascade, onUpdate: NoAction)\\n  user           user         @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)\\n\\n  @@index([organizationId])\\n  @@index([userId])\\n  @@schema(\\\"neon_auth\\\")\\n}\\n\\nmodel organization {\\n  id         String       @id @default(dbgenerated(\\\"gen_random_uuid()\\\")) @db.Uuid\\n  name       String\\n  slug       String       @unique\\n  logo       String?\\n  createdAt  DateTime     @db.Timestamptz(6)\\n  metadata   String?\\n  invitation invitation[]\\n  member     member[]\\n\\n  @@schema(\\\"neon_auth\\\")\\n}\\n\\nmodel project_config {\\n  id                 String   @id @default(dbgenerated(\\\"gen_random_uuid()\\\")) @db.Uuid\\n  name               String\\n  endpoint_id        String   @unique\\n  created_at         DateTime @default(now()) @db.Timestamptz(6)\\n  updated_at         DateTime @default(now()) @db.Timestamptz(6)\\n  trusted_origins    Json\\n  social_providers   Json\\n  email_provider     Json?\\n  email_and_password Json?\\n  allow_localhost    Boolean\\n\\n  @@schema(\\\"neon_auth\\\")\\n}\\n\\nmodel session {\\n  id                   String   @id @default(dbgenerated(\\\"gen_random_uuid()\\\")) @db.Uuid\\n  expiresAt            DateTime @db.Timestamptz(6)\\n  token                String   @unique\\n  createdAt            DateTime @default(now()) @db.Timestamptz(6)\\n  updatedAt            DateTime @db.Timestamptz(6)\\n  ipAddress            String?\\n  userAgent            String?\\n  userId               String   @db.Uuid\\n  impersonatedBy       String?\\n  activeOrganizationId String?\\n  user                 user     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)\\n\\n  @@index([userId])\\n  @@schema(\\\"neon_auth\\\")\\n}\\n\\nmodel user {\\n  id            String       @id @default(dbgenerated(\\\"gen_random_uuid()\\\")) @db.Uuid\\n  name          String\\n  email         String       @unique\\n  emailVerified Boolean\\n  image         String?\\n  createdAt     DateTime     @default(now()) @db.Timestamptz(6)\\n  updatedAt     DateTime     @default(now()) @db.Timestamptz(6)\\n  role          String?\\n  banned        Boolean?\\n  banReason     String?\\n  banExpires    DateTime?    @db.Timestamptz(6)\\n  account       account[]\\n  invitation    invitation[]\\n  member        member[]\\n  session       session[]\\n\\n  @@schema(\\\"neon_auth\\\")\\n}\\n\\nmodel verification {\\n  id         String   @id @default(dbgenerated(\\\"gen_random_uuid()\\\")) @db.Uuid\\n  identifier String\\n  value      String\\n  expiresAt  DateTime @db.Timestamptz(6)\\n  createdAt  DateTime @default(now()) @db.Timestamptz(6)\\n  updatedAt  DateTime @default(now()) @db.Timestamptz(6)\\n\\n  @@index([identifier])\\n  @@schema(\\\"neon_auth\\\")\\n}\\n\\nenum cook_time {\\n  MIN_10\\n  MIN_20\\n  MIN_30\\n  MIN_40\\n  MIN_50\\n  MIN_60\\n  MIN_00\\n\\n  @@schema(\\\"recipe_management\\\")\\n}\\n\\nenum fractions {\\n  F_1_16\\n  F_1_8\\n  F_3_16\\n  F_1_4\\n  F_5_16\\n  F_1_3\\n  F_3_8\\n  F_7_16\\n  F_1_2\\n  F_9_16\\n  F_5_8\\n  F_2_3\\n  F_11_16\\n  F_3_4\\n  F_13_16\\n  F_7_8\\n  F_15_16\\n\\n  @@schema(\\\"recipe_management\\\")\\n}\\n\\nenum ingredient_type {\\n  Grains___Legumes     @map(\\\"Grains & Legumes\\\")\\n  Produce__Fresh_      @map(\\\"Produce (Fresh)\\\")\\n  Dairy___Refrigerated @map(\\\"Dairy & Refrigerated\\\")\\n  Proteins\\n  Pantry_Staples       @map(\\\"Pantry Staples\\\")\\n  Spices___Seasonings  @map(\\\"Spices & Seasonings\\\")\\n\\n  @@schema(\\\"recipe_management\\\")\\n}\\n\\nenum meal_type {\\n  Breakfast\\n  Lunch\\n  Dinner\\n  Dessert\\n  Drink\\n  Snack\\n\\n  @@schema(\\\"recipe_management\\\")\\n}\\n\\nenum measurement_type {\\n  Cups\\n  Teaspoons\\n  Tablespoons\\n  Fluid\\n  Ounces\\n  Pounds\\n  None_       @map(\\\"/None/\\\")\\n  Grams\\n  Kilograms\\n  Milliliters\\n\\n  @@schema(\\\"recipe_management\\\")\\n}\\n\\nenum prep_time {\\n  MIN_10\\n  MIN_20\\n  MIN_30\\n  MIN_40\\n  MIN_50\\n  MIN_60\\n  MIN_00\\n\\n  @@schema(\\\"recipe_management\\\")\\n}\\n\",\n  \"runtimeDataModel\": {\n    \"models\": {},\n    \"enums\": {},\n    \"types\": {}\n  }\n}\n\nconfig.runtimeDataModel = JSON.parse(\"{\\\"models\\\":{\\\"all_ingredients\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"created_at\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"name\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"type\\\",\\\"kind\\\":\\\"enum\\\",\\\"type\\\":\\\"ingredient_type\\\"},{\\\"name\\\":\\\"recipe_ingredients\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"recipe_ingredients\\\",\\\"relationName\\\":\\\"all_ingredientsTorecipe_ingredients\\\"}],\\\"dbName\\\":null},\\\"instructions\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"created_at\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"recipe_id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"instruction_number\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Decimal\\\"},{\\\"name\\\":\\\"instruction_text\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"recipes\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"recipes\\\",\\\"relationName\\\":\\\"instructionsTorecipes\\\"}],\\\"dbName\\\":null},\\\"recipe_ingredients\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"created_at\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"ingredient_id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"amount\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Decimal\\\"},{\\\"name\\\":\\\"recipe_id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"measurement_type\\\",\\\"kind\\\":\\\"enum\\\",\\\"type\\\":\\\"measurement_type\\\"},{\\\"name\\\":\\\"partial_amount\\\",\\\"kind\\\":\\\"enum\\\",\\\"type\\\":\\\"fractions\\\"},{\\\"name\\\":\\\"all_ingredients\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"all_ingredients\\\",\\\"relationName\\\":\\\"all_ingredientsTorecipe_ingredients\\\"},{\\\"name\\\":\\\"recipes\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"recipes\\\",\\\"relationName\\\":\\\"recipe_ingredientsTorecipes\\\"}],\\\"dbName\\\":null},\\\"recipes\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"created_at\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"title\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"meal_type\\\",\\\"kind\\\":\\\"enum\\\",\\\"type\\\":\\\"meal_type\\\"},{\\\"name\\\":\\\"cook_time\\\",\\\"kind\\\":\\\"enum\\\",\\\"type\\\":\\\"cook_time\\\"},{\\\"name\\\":\\\"prep_time\\\",\\\"kind\\\":\\\"enum\\\",\\\"type\\\":\\\"prep_time\\\"},{\\\"name\\\":\\\"owner_id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"instructions\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"instructions\\\",\\\"relationName\\\":\\\"instructionsTorecipes\\\"},{\\\"name\\\":\\\"recipe_ingredients\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"recipe_ingredients\\\",\\\"relationName\\\":\\\"recipe_ingredientsTorecipes\\\"}],\\\"dbName\\\":null},\\\"account\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"accountId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"providerId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"userId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"accessToken\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"refreshToken\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"idToken\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"accessTokenExpiresAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"refreshTokenExpiresAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"scope\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"password\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"user\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"user\\\",\\\"relationName\\\":\\\"accountTouser\\\"}],\\\"dbName\\\":null},\\\"invitation\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"organizationId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"email\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"role\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"status\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"expiresAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"inviterId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"user\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"user\\\",\\\"relationName\\\":\\\"invitationTouser\\\"},{\\\"name\\\":\\\"organization\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"organization\\\",\\\"relationName\\\":\\\"invitationToorganization\\\"}],\\\"dbName\\\":null},\\\"jwks\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"publicKey\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"privateKey\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"expiresAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null},\\\"member\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"organizationId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"userId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"role\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"organization\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"organization\\\",\\\"relationName\\\":\\\"memberToorganization\\\"},{\\\"name\\\":\\\"user\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"user\\\",\\\"relationName\\\":\\\"memberTouser\\\"}],\\\"dbName\\\":null},\\\"organization\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"name\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"slug\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"logo\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"metadata\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"invitation\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"invitation\\\",\\\"relationName\\\":\\\"invitationToorganization\\\"},{\\\"name\\\":\\\"member\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"member\\\",\\\"relationName\\\":\\\"memberToorganization\\\"}],\\\"dbName\\\":null},\\\"project_config\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"name\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"endpoint_id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"created_at\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updated_at\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"trusted_origins\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Json\\\"},{\\\"name\\\":\\\"social_providers\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Json\\\"},{\\\"name\\\":\\\"email_provider\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Json\\\"},{\\\"name\\\":\\\"email_and_password\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Json\\\"},{\\\"name\\\":\\\"allow_localhost\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Boolean\\\"}],\\\"dbName\\\":null},\\\"session\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"expiresAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"token\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"ipAddress\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"userAgent\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"userId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"impersonatedBy\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"activeOrganizationId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"user\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"user\\\",\\\"relationName\\\":\\\"sessionTouser\\\"}],\\\"dbName\\\":null},\\\"user\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"name\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"email\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"emailVerified\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Boolean\\\"},{\\\"name\\\":\\\"image\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"role\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"banned\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Boolean\\\"},{\\\"name\\\":\\\"banReason\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"banExpires\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"account\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"account\\\",\\\"relationName\\\":\\\"accountTouser\\\"},{\\\"name\\\":\\\"invitation\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"invitation\\\",\\\"relationName\\\":\\\"invitationTouser\\\"},{\\\"name\\\":\\\"member\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"member\\\",\\\"relationName\\\":\\\"memberTouser\\\"},{\\\"name\\\":\\\"session\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"session\\\",\\\"relationName\\\":\\\"sessionTouser\\\"}],\\\"dbName\\\":null},\\\"verification\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"identifier\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"value\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"expiresAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null}},\\\"enums\\\":{},\\\"types\\\":{}}\")\n\nasync function decodeBase64AsWasm(wasmBase64: string): Promise<WebAssembly.Module> {\n  const { Buffer } = await import('node:buffer')\n  const wasmArray = Buffer.from(wasmBase64, 'base64')\n  return new WebAssembly.Module(wasmArray)\n}\n\nconfig.compilerWasm = {\n  getRuntime: async () => await import(\"@prisma/client/runtime/query_compiler_fast_bg.postgresql.mjs\"),\n\n  getQueryCompilerWasmModule: async () => {\n    const { wasm } = await import(\"@prisma/client/runtime/query_compiler_fast_bg.postgresql.wasm-base64.mjs\")\n    return await decodeBase64AsWasm(wasm)\n  },\n\n  importName: \"./query_compiler_fast_bg.js\"\n}\n\n\n\nexport type LogOptions<ClientOptions extends Prisma.PrismaClientOptions> =\n  'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never\n\nexport interface PrismaClientConstructor {\n    /**\n   * ## Prisma Client\n   * \n   * Type-safe database client for TypeScript\n   * @example\n   * ```\n   * const prisma = new PrismaClient()\n   * // Fetch zero or more All_ingredients\n   * const all_ingredients = await prisma.all_ingredients.findMany()\n   * ```\n   * \n   * Read more in our [docs](https://pris.ly/d/client).\n   */\n\n  new <\n    Options extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,\n    LogOpts extends LogOptions<Options> = LogOptions<Options>,\n    OmitOpts extends Prisma.PrismaClientOptions['omit'] = Options extends { omit: infer U } ? U : Prisma.PrismaClientOptions['omit'],\n    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs\n  >(options: Prisma.Subset<Options, Prisma.PrismaClientOptions> ): PrismaClient<LogOpts, OmitOpts, ExtArgs>\n}\n\n/**\n * ## Prisma Client\n * \n * Type-safe database client for TypeScript\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more All_ingredients\n * const all_ingredients = await prisma.all_ingredients.findMany()\n * ```\n * \n * Read more in our [docs](https://pris.ly/d/client).\n */\n\nexport interface PrismaClient<\n  in LogOpts extends Prisma.LogLevel = never,\n  in out OmitOpts extends Prisma.PrismaClientOptions['omit'] = undefined,\n  in out ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs\n> {\n  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }\n\n  $on<V extends LogOpts>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;\n\n  /**\n   * Connect with the database\n   */\n  $connect(): runtime.Types.Utils.JsPromise<void>;\n\n  /**\n   * Disconnect from the database\n   */\n  $disconnect(): runtime.Types.Utils.JsPromise<void>;\n\n/**\n   * Executes a prepared raw query and returns the number of affected rows.\n   * @example\n   * ```\n   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Executes a raw query and returns the number of affected rows.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Performs a prepared raw query and returns the `SELECT` data.\n   * @example\n   * ```\n   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;\n\n  /**\n   * Performs a raw query and returns the `SELECT` data.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;\n\n\n  /**\n   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.\n   * @example\n   * ```\n   * const [george, bob, alice] = await prisma.$transaction([\n   *   prisma.user.create({ data: { name: 'George' } }),\n   *   prisma.user.create({ data: { name: 'Bob' } }),\n   *   prisma.user.create({ data: { name: 'Alice' } }),\n   * ])\n   * ```\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).\n   */\n  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>\n\n  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => runtime.Types.Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<R>\n\n  $extends: runtime.Types.Extensions.ExtendsHook<\"extends\", Prisma.TypeMapCb<OmitOpts>, ExtArgs, runtime.Types.Utils.Call<Prisma.TypeMapCb<OmitOpts>, {\n    extArgs: ExtArgs\n  }>>\n\n      /**\n   * `prisma.all_ingredients`: Exposes CRUD operations for the **all_ingredients** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more All_ingredients\n    * const all_ingredients = await prisma.all_ingredients.findMany()\n    * ```\n    */\n  get all_ingredients(): Prisma.all_ingredientsDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.instructions`: Exposes CRUD operations for the **instructions** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Instructions\n    * const instructions = await prisma.instructions.findMany()\n    * ```\n    */\n  get instructions(): Prisma.instructionsDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.recipe_ingredients`: Exposes CRUD operations for the **recipe_ingredients** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Recipe_ingredients\n    * const recipe_ingredients = await prisma.recipe_ingredients.findMany()\n    * ```\n    */\n  get recipe_ingredients(): Prisma.recipe_ingredientsDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.recipes`: Exposes CRUD operations for the **recipes** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Recipes\n    * const recipes = await prisma.recipes.findMany()\n    * ```\n    */\n  get recipes(): Prisma.recipesDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.account`: Exposes CRUD operations for the **account** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Accounts\n    * const accounts = await prisma.account.findMany()\n    * ```\n    */\n  get account(): Prisma.accountDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.invitation`: Exposes CRUD operations for the **invitation** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Invitations\n    * const invitations = await prisma.invitation.findMany()\n    * ```\n    */\n  get invitation(): Prisma.invitationDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.jwks`: Exposes CRUD operations for the **jwks** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Jwks\n    * const jwks = await prisma.jwks.findMany()\n    * ```\n    */\n  get jwks(): Prisma.jwksDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.member`: Exposes CRUD operations for the **member** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Members\n    * const members = await prisma.member.findMany()\n    * ```\n    */\n  get member(): Prisma.memberDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.organization`: Exposes CRUD operations for the **organization** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Organizations\n    * const organizations = await prisma.organization.findMany()\n    * ```\n    */\n  get organization(): Prisma.organizationDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.project_config`: Exposes CRUD operations for the **project_config** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Project_configs\n    * const project_configs = await prisma.project_config.findMany()\n    * ```\n    */\n  get project_config(): Prisma.project_configDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.session`: Exposes CRUD operations for the **session** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Sessions\n    * const sessions = await prisma.session.findMany()\n    * ```\n    */\n  get session(): Prisma.sessionDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.user`: Exposes CRUD operations for the **user** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Users\n    * const users = await prisma.user.findMany()\n    * ```\n    */\n  get user(): Prisma.userDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.verification`: Exposes CRUD operations for the **verification** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Verifications\n    * const verifications = await prisma.verification.findMany()\n    * ```\n    */\n  get verification(): Prisma.verificationDelegate<ExtArgs, { omit: OmitOpts }>;\n}\n\nexport function getPrismaClientClass(): PrismaClientConstructor {\n  return runtime.getPrismaClient(config) as unknown as PrismaClientConstructor\n}\n"],"names":[],"mappings":";;;;AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;;;CAMC,GAED;;AAIA,MAAM,SAAwC;IAC5C,mBAAmB,EAAE;IACrB,iBAAiB;IACjB,iBAAiB;IACjB,kBAAkB;IAClB,gBAAgB;IAChB,oBAAoB;QAClB,UAAU,CAAC;QACX,SAAS,CAAC;QACV,SAAS,CAAC;IACZ;AACF;AAEA,OAAO,gBAAgB,GAAG,KAAK,KAAK,CAAC;AAErC,eAAe,mBAAmB,UAAkB;IAClD,MAAM,EAAE,MAAM,EAAE,GAAG;IACnB,MAAM,YAAY,OAAO,IAAI,CAAC,YAAY;IAC1C,OAAO,IAAI,YAAY,MAAM,CAAC;AAChC;AAEA,OAAO,YAAY,GAAG;IACpB,YAAY,UAAY;IAExB,4BAA4B;QAC1B,MAAM,EAAE,IAAI,EAAE,GAAG;QACjB,OAAO,MAAM,mBAAmB;IAClC;IAEA,YAAY;AACd;AAsQO,SAAS;IACd,OAAO,mPAAuB,CAAC;AACjC"}},
    {"offset": {"line": 73, "column": 0}, "map": {"version":3,"sources":["file:///C:/Git/Senior%20Project/RecipeWebsite/src/generated/prisma/internal/prismaNamespace.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * WARNING: This is an internal file that is subject to change!\n *\n * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘\n *\n * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.\n * While this enables partial backward compatibility, it is not part of the stable public API.\n *\n * If you are looking for your Models, Enums, and Input Types, please import them from the respective\n * model files in the `model` directory!\n */\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport type * as Prisma from \"../models\"\nimport { type PrismaClient } from \"./class\"\n\nexport type * from '../models'\n\nexport type DMMF = typeof runtime.DMMF\n\nexport type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>\n\n/**\n * Prisma Errors\n */\n\nexport const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\nexport type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\n\nexport const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\nexport type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\n\nexport const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\nexport type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\n\nexport const PrismaClientInitializationError = runtime.PrismaClientInitializationError\nexport type PrismaClientInitializationError = runtime.PrismaClientInitializationError\n\nexport const PrismaClientValidationError = runtime.PrismaClientValidationError\nexport type PrismaClientValidationError = runtime.PrismaClientValidationError\n\n/**\n * Re-export of sql-template-tag\n */\nexport const sql = runtime.sqltag\nexport const empty = runtime.empty\nexport const join = runtime.join\nexport const raw = runtime.raw\nexport const Sql = runtime.Sql\nexport type Sql = runtime.Sql\n\n\n\n/**\n * Decimal.js\n */\nexport const Decimal = runtime.Decimal\nexport type Decimal = runtime.Decimal\n\nexport type DecimalJsLike = runtime.DecimalJsLike\n\n/**\n* Extensions\n*/\nexport type Extension = runtime.Types.Extensions.UserArgs\nexport const getExtensionContext = runtime.Extensions.getExtensionContext\nexport type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>\nexport type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>\nexport type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>\nexport type Exact<A, W> = runtime.Types.Public.Exact<A, W>\n\nexport type PrismaVersion = {\n  client: string\n  engine: string\n}\n\n/**\n * Prisma Client JS version: 7.3.0\n * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735\n */\nexport const prismaVersion: PrismaVersion = {\n  client: \"7.3.0\",\n  engine: \"9d6ad21cbbceab97458517b147a6a09ff43aa735\"\n}\n\n/**\n * Utility Types\n */\n\nexport type Bytes = runtime.Bytes\nexport type JsonObject = runtime.JsonObject\nexport type JsonArray = runtime.JsonArray\nexport type JsonValue = runtime.JsonValue\nexport type InputJsonObject = runtime.InputJsonObject\nexport type InputJsonArray = runtime.InputJsonArray\nexport type InputJsonValue = runtime.InputJsonValue\n\n\nexport const NullTypes = {\n  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),\n  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),\n  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),\n}\n/**\n * Helper for filtering JSON entries that have `null` on the database (empty on the db)\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const DbNull = runtime.DbNull\n\n/**\n * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const JsonNull = runtime.JsonNull\n\n/**\n * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const AnyNull = runtime.AnyNull\n\n\ntype SelectAndInclude = {\n  select: any\n  include: any\n}\n\ntype SelectAndOmit = {\n  select: any\n  omit: any\n}\n\n/**\n * From T, pick a set of properties whose keys are in the union K\n */\ntype Prisma__Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n};\n\nexport type Enumerable<T> = T | Array<T>;\n\n/**\n * Subset\n * @desc From `T` pick properties that exist in `U`. Simple version of Intersection\n */\nexport type Subset<T, U> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never;\n};\n\n/**\n * SelectSubset\n * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.\n * Additionally, it validates, if both select and include are present. If the case, it errors.\n */\nexport type SelectSubset<T, U> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never\n} &\n  (T extends SelectAndInclude\n    ? 'Please either choose `select` or `include`.'\n    : T extends SelectAndOmit\n      ? 'Please either choose `select` or `omit`.'\n      : {})\n\n/**\n * Subset + Intersection\n * @desc From `T` pick properties that exist in `U` and intersect `K`\n */\nexport type SubsetIntersection<T, U, K> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never\n} &\n  K\n\ntype Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\n/**\n * XOR is needed to have a real mutually exclusive union type\n * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types\n */\nexport type XOR<T, U> =\n  T extends object ?\n  U extends object ?\n    (Without<T, U> & U) | (Without<U, T> & T)\n  : U : T\n\n\n/**\n * Is T a Record?\n */\ntype IsObject<T extends any> = T extends Array<any>\n? False\n: T extends Date\n? False\n: T extends Uint8Array\n? False\n: T extends BigInt\n? False\n: T extends object\n? True\n: False\n\n\n/**\n * If it's T[], return T\n */\nexport type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T\n\n/**\n * From ts-toolbelt\n */\n\ntype __Either<O extends object, K extends Key> = Omit<O, K> &\n  {\n    // Merge all but K\n    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities\n  }[K]\n\ntype EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>\n\ntype EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>\n\ntype _Either<\n  O extends object,\n  K extends Key,\n  strict extends Boolean\n> = {\n  1: EitherStrict<O, K>\n  0: EitherLoose<O, K>\n}[strict]\n\nexport type Either<\n  O extends object,\n  K extends Key,\n  strict extends Boolean = 1\n> = O extends unknown ? _Either<O, K, strict> : never\n\nexport type Union = any\n\nexport type PatchUndefined<O extends object, O1 extends object> = {\n  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]\n} & {}\n\n/** Helper Types for \"Merge\" **/\nexport type IntersectOf<U extends Union> = (\n  U extends unknown ? (k: U) => void : never\n) extends (k: infer I) => void\n  ? I\n  : never\n\nexport type Overwrite<O extends object, O1 extends object> = {\n    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];\n} & {};\n\ntype _Merge<U extends object> = IntersectOf<Overwrite<U, {\n    [K in keyof U]-?: At<U, K>;\n}>>;\n\ntype Key = string | number | symbol;\ntype AtStrict<O extends object, K extends Key> = O[K & keyof O];\ntype AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;\nexport type At<O extends object, K extends Key, strict extends Boolean = 1> = {\n    1: AtStrict<O, K>;\n    0: AtLoose<O, K>;\n}[strict];\n\nexport type ComputeRaw<A extends any> = A extends Function ? A : {\n  [K in keyof A]: A[K];\n} & {};\n\nexport type OptionalFlat<O> = {\n  [K in keyof O]?: O[K];\n} & {};\n\ntype _Record<K extends keyof any, T> = {\n  [P in K]: T;\n};\n\n// cause typescript not to expand types and preserve names\ntype NoExpand<T> = T extends unknown ? T : never;\n\n// this type assumes the passed object is entirely optional\nexport type AtLeast<O extends object, K extends string> = NoExpand<\n  O extends unknown\n  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)\n    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O\n  : never>;\n\ntype _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;\n\nexport type Strict<U extends object> = ComputeRaw<_Strict<U>>;\n/** End Helper Types for \"Merge\" **/\n\nexport type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;\n\nexport type Boolean = True | False\n\nexport type True = 1\n\nexport type False = 0\n\nexport type Not<B extends Boolean> = {\n  0: 1\n  1: 0\n}[B]\n\nexport type Extends<A1 extends any, A2 extends any> = [A1] extends [never]\n  ? 0 // anything `never` is false\n  : A1 extends A2\n  ? 1\n  : 0\n\nexport type Has<U extends Union, U1 extends Union> = Not<\n  Extends<Exclude<U1, U>, U1>\n>\n\nexport type Or<B1 extends Boolean, B2 extends Boolean> = {\n  0: {\n    0: 0\n    1: 1\n  }\n  1: {\n    0: 1\n    1: 1\n  }\n}[B1][B2]\n\nexport type Keys<U extends Union> = U extends unknown ? keyof U : never\n\nexport type GetScalarType<T, O> = O extends object ? {\n  [P in keyof T]: P extends keyof O\n    ? O[P]\n    : never\n} : never\n\ntype FieldPaths<\n  T,\n  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>\n> = IsObject<T> extends True ? U : T\n\nexport type GetHavingFields<T> = {\n  [K in keyof T]: Or<\n    Or<Extends<'OR', K>, Extends<'AND', K>>,\n    Extends<'NOT', K>\n  > extends True\n    ? // infer is only needed to not hit TS limit\n      // based on the brilliant idea of Pierre-Antoine Mills\n      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437\n      T[K] extends infer TK\n      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>\n      : never\n    : {} extends FieldPaths<T[K]>\n    ? never\n    : K\n}[keyof T]\n\n/**\n * Convert tuple to union\n */\ntype _TupleToUnion<T> = T extends (infer E)[] ? E : never\ntype TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>\nexport type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T\n\n/**\n * Like `Pick`, but additionally can also accept an array of keys\n */\nexport type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>\n\n/**\n * Exclude all keys with underscores\n */\nexport type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T\n\n\nexport type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>\n\ntype FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>\n\n\nexport const ModelName = {\n  all_ingredients: 'all_ingredients',\n  instructions: 'instructions',\n  recipe_ingredients: 'recipe_ingredients',\n  recipes: 'recipes',\n  account: 'account',\n  invitation: 'invitation',\n  jwks: 'jwks',\n  member: 'member',\n  organization: 'organization',\n  project_config: 'project_config',\n  session: 'session',\n  user: 'user',\n  verification: 'verification'\n} as const\n\nexport type ModelName = (typeof ModelName)[keyof typeof ModelName]\n\n\n\nexport interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {\n  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>\n}\n\nexport type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {\n  globalOmitOptions: {\n    omit: GlobalOmitOptions\n  }\n  meta: {\n    modelProps: \"all_ingredients\" | \"instructions\" | \"recipe_ingredients\" | \"recipes\" | \"account\" | \"invitation\" | \"jwks\" | \"member\" | \"organization\" | \"project_config\" | \"session\" | \"user\" | \"verification\"\n    txIsolationLevel: TransactionIsolationLevel\n  }\n  model: {\n    all_ingredients: {\n      payload: Prisma.$all_ingredientsPayload<ExtArgs>\n      fields: Prisma.all_ingredientsFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.all_ingredientsFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$all_ingredientsPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.all_ingredientsFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$all_ingredientsPayload>\n        }\n        findFirst: {\n          args: Prisma.all_ingredientsFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$all_ingredientsPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.all_ingredientsFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$all_ingredientsPayload>\n        }\n        findMany: {\n          args: Prisma.all_ingredientsFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$all_ingredientsPayload>[]\n        }\n        create: {\n          args: Prisma.all_ingredientsCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$all_ingredientsPayload>\n        }\n        createMany: {\n          args: Prisma.all_ingredientsCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.all_ingredientsCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$all_ingredientsPayload>[]\n        }\n        delete: {\n          args: Prisma.all_ingredientsDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$all_ingredientsPayload>\n        }\n        update: {\n          args: Prisma.all_ingredientsUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$all_ingredientsPayload>\n        }\n        deleteMany: {\n          args: Prisma.all_ingredientsDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.all_ingredientsUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.all_ingredientsUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$all_ingredientsPayload>[]\n        }\n        upsert: {\n          args: Prisma.all_ingredientsUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$all_ingredientsPayload>\n        }\n        aggregate: {\n          args: Prisma.All_ingredientsAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateAll_ingredients>\n        }\n        groupBy: {\n          args: Prisma.all_ingredientsGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.All_ingredientsGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.all_ingredientsCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.All_ingredientsCountAggregateOutputType> | number\n        }\n      }\n    }\n    instructions: {\n      payload: Prisma.$instructionsPayload<ExtArgs>\n      fields: Prisma.instructionsFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.instructionsFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$instructionsPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.instructionsFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$instructionsPayload>\n        }\n        findFirst: {\n          args: Prisma.instructionsFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$instructionsPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.instructionsFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$instructionsPayload>\n        }\n        findMany: {\n          args: Prisma.instructionsFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$instructionsPayload>[]\n        }\n        create: {\n          args: Prisma.instructionsCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$instructionsPayload>\n        }\n        createMany: {\n          args: Prisma.instructionsCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.instructionsCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$instructionsPayload>[]\n        }\n        delete: {\n          args: Prisma.instructionsDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$instructionsPayload>\n        }\n        update: {\n          args: Prisma.instructionsUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$instructionsPayload>\n        }\n        deleteMany: {\n          args: Prisma.instructionsDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.instructionsUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.instructionsUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$instructionsPayload>[]\n        }\n        upsert: {\n          args: Prisma.instructionsUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$instructionsPayload>\n        }\n        aggregate: {\n          args: Prisma.InstructionsAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateInstructions>\n        }\n        groupBy: {\n          args: Prisma.instructionsGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.InstructionsGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.instructionsCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.InstructionsCountAggregateOutputType> | number\n        }\n      }\n    }\n    recipe_ingredients: {\n      payload: Prisma.$recipe_ingredientsPayload<ExtArgs>\n      fields: Prisma.recipe_ingredientsFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.recipe_ingredientsFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipe_ingredientsPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.recipe_ingredientsFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipe_ingredientsPayload>\n        }\n        findFirst: {\n          args: Prisma.recipe_ingredientsFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipe_ingredientsPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.recipe_ingredientsFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipe_ingredientsPayload>\n        }\n        findMany: {\n          args: Prisma.recipe_ingredientsFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipe_ingredientsPayload>[]\n        }\n        create: {\n          args: Prisma.recipe_ingredientsCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipe_ingredientsPayload>\n        }\n        createMany: {\n          args: Prisma.recipe_ingredientsCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.recipe_ingredientsCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipe_ingredientsPayload>[]\n        }\n        delete: {\n          args: Prisma.recipe_ingredientsDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipe_ingredientsPayload>\n        }\n        update: {\n          args: Prisma.recipe_ingredientsUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipe_ingredientsPayload>\n        }\n        deleteMany: {\n          args: Prisma.recipe_ingredientsDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.recipe_ingredientsUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.recipe_ingredientsUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipe_ingredientsPayload>[]\n        }\n        upsert: {\n          args: Prisma.recipe_ingredientsUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipe_ingredientsPayload>\n        }\n        aggregate: {\n          args: Prisma.Recipe_ingredientsAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateRecipe_ingredients>\n        }\n        groupBy: {\n          args: Prisma.recipe_ingredientsGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.Recipe_ingredientsGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.recipe_ingredientsCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.Recipe_ingredientsCountAggregateOutputType> | number\n        }\n      }\n    }\n    recipes: {\n      payload: Prisma.$recipesPayload<ExtArgs>\n      fields: Prisma.recipesFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.recipesFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipesPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.recipesFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipesPayload>\n        }\n        findFirst: {\n          args: Prisma.recipesFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipesPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.recipesFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipesPayload>\n        }\n        findMany: {\n          args: Prisma.recipesFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipesPayload>[]\n        }\n        create: {\n          args: Prisma.recipesCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipesPayload>\n        }\n        createMany: {\n          args: Prisma.recipesCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.recipesCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipesPayload>[]\n        }\n        delete: {\n          args: Prisma.recipesDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipesPayload>\n        }\n        update: {\n          args: Prisma.recipesUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipesPayload>\n        }\n        deleteMany: {\n          args: Prisma.recipesDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.recipesUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.recipesUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipesPayload>[]\n        }\n        upsert: {\n          args: Prisma.recipesUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$recipesPayload>\n        }\n        aggregate: {\n          args: Prisma.RecipesAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateRecipes>\n        }\n        groupBy: {\n          args: Prisma.recipesGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.RecipesGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.recipesCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.RecipesCountAggregateOutputType> | number\n        }\n      }\n    }\n    account: {\n      payload: Prisma.$accountPayload<ExtArgs>\n      fields: Prisma.accountFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.accountFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.accountFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload>\n        }\n        findFirst: {\n          args: Prisma.accountFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.accountFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload>\n        }\n        findMany: {\n          args: Prisma.accountFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload>[]\n        }\n        create: {\n          args: Prisma.accountCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload>\n        }\n        createMany: {\n          args: Prisma.accountCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.accountCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload>[]\n        }\n        delete: {\n          args: Prisma.accountDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload>\n        }\n        update: {\n          args: Prisma.accountUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload>\n        }\n        deleteMany: {\n          args: Prisma.accountDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.accountUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.accountUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload>[]\n        }\n        upsert: {\n          args: Prisma.accountUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload>\n        }\n        aggregate: {\n          args: Prisma.AccountAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateAccount>\n        }\n        groupBy: {\n          args: Prisma.accountGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AccountGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.accountCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AccountCountAggregateOutputType> | number\n        }\n      }\n    }\n    invitation: {\n      payload: Prisma.$invitationPayload<ExtArgs>\n      fields: Prisma.invitationFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.invitationFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$invitationPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.invitationFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$invitationPayload>\n        }\n        findFirst: {\n          args: Prisma.invitationFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$invitationPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.invitationFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$invitationPayload>\n        }\n        findMany: {\n          args: Prisma.invitationFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$invitationPayload>[]\n        }\n        create: {\n          args: Prisma.invitationCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$invitationPayload>\n        }\n        createMany: {\n          args: Prisma.invitationCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.invitationCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$invitationPayload>[]\n        }\n        delete: {\n          args: Prisma.invitationDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$invitationPayload>\n        }\n        update: {\n          args: Prisma.invitationUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$invitationPayload>\n        }\n        deleteMany: {\n          args: Prisma.invitationDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.invitationUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.invitationUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$invitationPayload>[]\n        }\n        upsert: {\n          args: Prisma.invitationUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$invitationPayload>\n        }\n        aggregate: {\n          args: Prisma.InvitationAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateInvitation>\n        }\n        groupBy: {\n          args: Prisma.invitationGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.InvitationGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.invitationCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.InvitationCountAggregateOutputType> | number\n        }\n      }\n    }\n    jwks: {\n      payload: Prisma.$jwksPayload<ExtArgs>\n      fields: Prisma.jwksFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.jwksFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$jwksPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.jwksFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$jwksPayload>\n        }\n        findFirst: {\n          args: Prisma.jwksFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$jwksPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.jwksFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$jwksPayload>\n        }\n        findMany: {\n          args: Prisma.jwksFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$jwksPayload>[]\n        }\n        create: {\n          args: Prisma.jwksCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$jwksPayload>\n        }\n        createMany: {\n          args: Prisma.jwksCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.jwksCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$jwksPayload>[]\n        }\n        delete: {\n          args: Prisma.jwksDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$jwksPayload>\n        }\n        update: {\n          args: Prisma.jwksUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$jwksPayload>\n        }\n        deleteMany: {\n          args: Prisma.jwksDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.jwksUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.jwksUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$jwksPayload>[]\n        }\n        upsert: {\n          args: Prisma.jwksUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$jwksPayload>\n        }\n        aggregate: {\n          args: Prisma.JwksAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateJwks>\n        }\n        groupBy: {\n          args: Prisma.jwksGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.JwksGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.jwksCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.JwksCountAggregateOutputType> | number\n        }\n      }\n    }\n    member: {\n      payload: Prisma.$memberPayload<ExtArgs>\n      fields: Prisma.memberFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.memberFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$memberPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.memberFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$memberPayload>\n        }\n        findFirst: {\n          args: Prisma.memberFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$memberPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.memberFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$memberPayload>\n        }\n        findMany: {\n          args: Prisma.memberFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$memberPayload>[]\n        }\n        create: {\n          args: Prisma.memberCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$memberPayload>\n        }\n        createMany: {\n          args: Prisma.memberCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.memberCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$memberPayload>[]\n        }\n        delete: {\n          args: Prisma.memberDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$memberPayload>\n        }\n        update: {\n          args: Prisma.memberUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$memberPayload>\n        }\n        deleteMany: {\n          args: Prisma.memberDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.memberUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.memberUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$memberPayload>[]\n        }\n        upsert: {\n          args: Prisma.memberUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$memberPayload>\n        }\n        aggregate: {\n          args: Prisma.MemberAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateMember>\n        }\n        groupBy: {\n          args: Prisma.memberGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.MemberGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.memberCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.MemberCountAggregateOutputType> | number\n        }\n      }\n    }\n    organization: {\n      payload: Prisma.$organizationPayload<ExtArgs>\n      fields: Prisma.organizationFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.organizationFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$organizationPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.organizationFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$organizationPayload>\n        }\n        findFirst: {\n          args: Prisma.organizationFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$organizationPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.organizationFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$organizationPayload>\n        }\n        findMany: {\n          args: Prisma.organizationFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$organizationPayload>[]\n        }\n        create: {\n          args: Prisma.organizationCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$organizationPayload>\n        }\n        createMany: {\n          args: Prisma.organizationCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.organizationCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$organizationPayload>[]\n        }\n        delete: {\n          args: Prisma.organizationDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$organizationPayload>\n        }\n        update: {\n          args: Prisma.organizationUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$organizationPayload>\n        }\n        deleteMany: {\n          args: Prisma.organizationDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.organizationUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.organizationUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$organizationPayload>[]\n        }\n        upsert: {\n          args: Prisma.organizationUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$organizationPayload>\n        }\n        aggregate: {\n          args: Prisma.OrganizationAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganization>\n        }\n        groupBy: {\n          args: Prisma.organizationGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.OrganizationGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.organizationCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.OrganizationCountAggregateOutputType> | number\n        }\n      }\n    }\n    project_config: {\n      payload: Prisma.$project_configPayload<ExtArgs>\n      fields: Prisma.project_configFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.project_configFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$project_configPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.project_configFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$project_configPayload>\n        }\n        findFirst: {\n          args: Prisma.project_configFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$project_configPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.project_configFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$project_configPayload>\n        }\n        findMany: {\n          args: Prisma.project_configFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$project_configPayload>[]\n        }\n        create: {\n          args: Prisma.project_configCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$project_configPayload>\n        }\n        createMany: {\n          args: Prisma.project_configCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.project_configCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$project_configPayload>[]\n        }\n        delete: {\n          args: Prisma.project_configDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$project_configPayload>\n        }\n        update: {\n          args: Prisma.project_configUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$project_configPayload>\n        }\n        deleteMany: {\n          args: Prisma.project_configDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.project_configUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.project_configUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$project_configPayload>[]\n        }\n        upsert: {\n          args: Prisma.project_configUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$project_configPayload>\n        }\n        aggregate: {\n          args: Prisma.Project_configAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateProject_config>\n        }\n        groupBy: {\n          args: Prisma.project_configGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.Project_configGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.project_configCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.Project_configCountAggregateOutputType> | number\n        }\n      }\n    }\n    session: {\n      payload: Prisma.$sessionPayload<ExtArgs>\n      fields: Prisma.sessionFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.sessionFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.sessionFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>\n        }\n        findFirst: {\n          args: Prisma.sessionFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.sessionFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>\n        }\n        findMany: {\n          args: Prisma.sessionFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>[]\n        }\n        create: {\n          args: Prisma.sessionCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>\n        }\n        createMany: {\n          args: Prisma.sessionCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.sessionCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>[]\n        }\n        delete: {\n          args: Prisma.sessionDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>\n        }\n        update: {\n          args: Prisma.sessionUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>\n        }\n        deleteMany: {\n          args: Prisma.sessionDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.sessionUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.sessionUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>[]\n        }\n        upsert: {\n          args: Prisma.sessionUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>\n        }\n        aggregate: {\n          args: Prisma.SessionAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateSession>\n        }\n        groupBy: {\n          args: Prisma.sessionGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.SessionGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.sessionCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.SessionCountAggregateOutputType> | number\n        }\n      }\n    }\n    user: {\n      payload: Prisma.$userPayload<ExtArgs>\n      fields: Prisma.userFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.userFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>\n        }\n        findFirst: {\n          args: Prisma.userFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.userFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>\n        }\n        findMany: {\n          args: Prisma.userFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>[]\n        }\n        create: {\n          args: Prisma.userCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>\n        }\n        createMany: {\n          args: Prisma.userCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.userCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>[]\n        }\n        delete: {\n          args: Prisma.userDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>\n        }\n        update: {\n          args: Prisma.userUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>\n        }\n        deleteMany: {\n          args: Prisma.userDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.userUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.userUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>[]\n        }\n        upsert: {\n          args: Prisma.userUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>\n        }\n        aggregate: {\n          args: Prisma.UserAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>\n        }\n        groupBy: {\n          args: Prisma.userGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.userCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number\n        }\n      }\n    }\n    verification: {\n      payload: Prisma.$verificationPayload<ExtArgs>\n      fields: Prisma.verificationFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.verificationFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.verificationFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload>\n        }\n        findFirst: {\n          args: Prisma.verificationFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.verificationFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload>\n        }\n        findMany: {\n          args: Prisma.verificationFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload>[]\n        }\n        create: {\n          args: Prisma.verificationCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload>\n        }\n        createMany: {\n          args: Prisma.verificationCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.verificationCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload>[]\n        }\n        delete: {\n          args: Prisma.verificationDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload>\n        }\n        update: {\n          args: Prisma.verificationUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload>\n        }\n        deleteMany: {\n          args: Prisma.verificationDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.verificationUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.verificationUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload>[]\n        }\n        upsert: {\n          args: Prisma.verificationUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload>\n        }\n        aggregate: {\n          args: Prisma.VerificationAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateVerification>\n        }\n        groupBy: {\n          args: Prisma.verificationGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.VerificationGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.verificationCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.VerificationCountAggregateOutputType> | number\n        }\n      }\n    }\n  }\n} & {\n  other: {\n    payload: any\n    operations: {\n      $executeRaw: {\n        args: [query: TemplateStringsArray | Sql, ...values: any[]],\n        result: any\n      }\n      $executeRawUnsafe: {\n        args: [query: string, ...values: any[]],\n        result: any\n      }\n      $queryRaw: {\n        args: [query: TemplateStringsArray | Sql, ...values: any[]],\n        result: any\n      }\n      $queryRawUnsafe: {\n        args: [query: string, ...values: any[]],\n        result: any\n      }\n    }\n  }\n}\n\n/**\n * Enums\n */\n\nexport const TransactionIsolationLevel = runtime.makeStrictEnum({\n  ReadUncommitted: 'ReadUncommitted',\n  ReadCommitted: 'ReadCommitted',\n  RepeatableRead: 'RepeatableRead',\n  Serializable: 'Serializable'\n} as const)\n\nexport type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]\n\n\nexport const All_ingredientsScalarFieldEnum = {\n  id: 'id',\n  created_at: 'created_at',\n  name: 'name',\n  type: 'type'\n} as const\n\nexport type All_ingredientsScalarFieldEnum = (typeof All_ingredientsScalarFieldEnum)[keyof typeof All_ingredientsScalarFieldEnum]\n\n\nexport const InstructionsScalarFieldEnum = {\n  id: 'id',\n  created_at: 'created_at',\n  recipe_id: 'recipe_id',\n  instruction_number: 'instruction_number',\n  instruction_text: 'instruction_text'\n} as const\n\nexport type InstructionsScalarFieldEnum = (typeof InstructionsScalarFieldEnum)[keyof typeof InstructionsScalarFieldEnum]\n\n\nexport const Recipe_ingredientsScalarFieldEnum = {\n  id: 'id',\n  created_at: 'created_at',\n  ingredient_id: 'ingredient_id',\n  amount: 'amount',\n  recipe_id: 'recipe_id',\n  measurement_type: 'measurement_type',\n  partial_amount: 'partial_amount'\n} as const\n\nexport type Recipe_ingredientsScalarFieldEnum = (typeof Recipe_ingredientsScalarFieldEnum)[keyof typeof Recipe_ingredientsScalarFieldEnum]\n\n\nexport const RecipesScalarFieldEnum = {\n  id: 'id',\n  created_at: 'created_at',\n  title: 'title',\n  meal_type: 'meal_type',\n  cook_time: 'cook_time',\n  prep_time: 'prep_time',\n  owner_id: 'owner_id'\n} as const\n\nexport type RecipesScalarFieldEnum = (typeof RecipesScalarFieldEnum)[keyof typeof RecipesScalarFieldEnum]\n\n\nexport const AccountScalarFieldEnum = {\n  id: 'id',\n  accountId: 'accountId',\n  providerId: 'providerId',\n  userId: 'userId',\n  accessToken: 'accessToken',\n  refreshToken: 'refreshToken',\n  idToken: 'idToken',\n  accessTokenExpiresAt: 'accessTokenExpiresAt',\n  refreshTokenExpiresAt: 'refreshTokenExpiresAt',\n  scope: 'scope',\n  password: 'password',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]\n\n\nexport const InvitationScalarFieldEnum = {\n  id: 'id',\n  organizationId: 'organizationId',\n  email: 'email',\n  role: 'role',\n  status: 'status',\n  expiresAt: 'expiresAt',\n  createdAt: 'createdAt',\n  inviterId: 'inviterId'\n} as const\n\nexport type InvitationScalarFieldEnum = (typeof InvitationScalarFieldEnum)[keyof typeof InvitationScalarFieldEnum]\n\n\nexport const JwksScalarFieldEnum = {\n  id: 'id',\n  publicKey: 'publicKey',\n  privateKey: 'privateKey',\n  createdAt: 'createdAt',\n  expiresAt: 'expiresAt'\n} as const\n\nexport type JwksScalarFieldEnum = (typeof JwksScalarFieldEnum)[keyof typeof JwksScalarFieldEnum]\n\n\nexport const MemberScalarFieldEnum = {\n  id: 'id',\n  organizationId: 'organizationId',\n  userId: 'userId',\n  role: 'role',\n  createdAt: 'createdAt'\n} as const\n\nexport type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]\n\n\nexport const OrganizationScalarFieldEnum = {\n  id: 'id',\n  name: 'name',\n  slug: 'slug',\n  logo: 'logo',\n  createdAt: 'createdAt',\n  metadata: 'metadata'\n} as const\n\nexport type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]\n\n\nexport const Project_configScalarFieldEnum = {\n  id: 'id',\n  name: 'name',\n  endpoint_id: 'endpoint_id',\n  created_at: 'created_at',\n  updated_at: 'updated_at',\n  trusted_origins: 'trusted_origins',\n  social_providers: 'social_providers',\n  email_provider: 'email_provider',\n  email_and_password: 'email_and_password',\n  allow_localhost: 'allow_localhost'\n} as const\n\nexport type Project_configScalarFieldEnum = (typeof Project_configScalarFieldEnum)[keyof typeof Project_configScalarFieldEnum]\n\n\nexport const SessionScalarFieldEnum = {\n  id: 'id',\n  expiresAt: 'expiresAt',\n  token: 'token',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt',\n  ipAddress: 'ipAddress',\n  userAgent: 'userAgent',\n  userId: 'userId',\n  impersonatedBy: 'impersonatedBy',\n  activeOrganizationId: 'activeOrganizationId'\n} as const\n\nexport type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]\n\n\nexport const UserScalarFieldEnum = {\n  id: 'id',\n  name: 'name',\n  email: 'email',\n  emailVerified: 'emailVerified',\n  image: 'image',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt',\n  role: 'role',\n  banned: 'banned',\n  banReason: 'banReason',\n  banExpires: 'banExpires'\n} as const\n\nexport type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]\n\n\nexport const VerificationScalarFieldEnum = {\n  id: 'id',\n  identifier: 'identifier',\n  value: 'value',\n  expiresAt: 'expiresAt',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]\n\n\nexport const SortOrder = {\n  asc: 'asc',\n  desc: 'desc'\n} as const\n\nexport type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]\n\n\nexport const JsonNullValueInput = {\n  JsonNull: JsonNull\n} as const\n\nexport type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]\n\n\nexport const NullableJsonNullValueInput = {\n  DbNull: DbNull,\n  JsonNull: JsonNull\n} as const\n\nexport type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]\n\n\nexport const QueryMode = {\n  default: 'default',\n  insensitive: 'insensitive'\n} as const\n\nexport type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]\n\n\nexport const NullsOrder = {\n  first: 'first',\n  last: 'last'\n} as const\n\nexport type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]\n\n\nexport const JsonNullValueFilter = {\n  DbNull: DbNull,\n  JsonNull: JsonNull,\n  AnyNull: AnyNull\n} as const\n\nexport type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]\n\n\n\n/**\n * Field references\n */\n\n\n/**\n * Reference to a field of type 'Int'\n */\nexport type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>\n    \n\n\n/**\n * Reference to a field of type 'Int[]'\n */\nexport type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>\n    \n\n\n/**\n * Reference to a field of type 'DateTime'\n */\nexport type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>\n    \n\n\n/**\n * Reference to a field of type 'DateTime[]'\n */\nexport type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>\n    \n\n\n/**\n * Reference to a field of type 'String'\n */\nexport type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>\n    \n\n\n/**\n * Reference to a field of type 'String[]'\n */\nexport type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>\n    \n\n\n/**\n * Reference to a field of type 'ingredient_type'\n */\nexport type Enumingredient_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ingredient_type'>\n    \n\n\n/**\n * Reference to a field of type 'ingredient_type[]'\n */\nexport type ListEnumingredient_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ingredient_type[]'>\n    \n\n\n/**\n * Reference to a field of type 'Decimal'\n */\nexport type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>\n    \n\n\n/**\n * Reference to a field of type 'Decimal[]'\n */\nexport type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>\n    \n\n\n/**\n * Reference to a field of type 'measurement_type'\n */\nexport type Enummeasurement_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'measurement_type'>\n    \n\n\n/**\n * Reference to a field of type 'measurement_type[]'\n */\nexport type ListEnummeasurement_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'measurement_type[]'>\n    \n\n\n/**\n * Reference to a field of type 'fractions'\n */\nexport type EnumfractionsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'fractions'>\n    \n\n\n/**\n * Reference to a field of type 'fractions[]'\n */\nexport type ListEnumfractionsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'fractions[]'>\n    \n\n\n/**\n * Reference to a field of type 'meal_type'\n */\nexport type Enummeal_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'meal_type'>\n    \n\n\n/**\n * Reference to a field of type 'meal_type[]'\n */\nexport type ListEnummeal_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'meal_type[]'>\n    \n\n\n/**\n * Reference to a field of type 'cook_time'\n */\nexport type Enumcook_timeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'cook_time'>\n    \n\n\n/**\n * Reference to a field of type 'cook_time[]'\n */\nexport type ListEnumcook_timeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'cook_time[]'>\n    \n\n\n/**\n * Reference to a field of type 'prep_time'\n */\nexport type Enumprep_timeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'prep_time'>\n    \n\n\n/**\n * Reference to a field of type 'prep_time[]'\n */\nexport type ListEnumprep_timeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'prep_time[]'>\n    \n\n\n/**\n * Reference to a field of type 'Json'\n */\nexport type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>\n    \n\n\n/**\n * Reference to a field of type 'QueryMode'\n */\nexport type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>\n    \n\n\n/**\n * Reference to a field of type 'Boolean'\n */\nexport type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>\n    \n\n\n/**\n * Reference to a field of type 'Float'\n */\nexport type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>\n    \n\n\n/**\n * Reference to a field of type 'Float[]'\n */\nexport type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>\n    \n\n/**\n * Batch Payload for updateMany & deleteMany & createMany\n */\nexport type BatchPayload = {\n  count: number\n}\n\nexport const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<\"define\", TypeMapCb, runtime.Types.Extensions.DefaultArgs>\nexport type DefaultPrismaClient = PrismaClient\nexport type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\nexport type PrismaClientOptions = ({\n  /**\n   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.\n   */\n  adapter: runtime.SqlDriverAdapterFactory\n  accelerateUrl?: never\n} | {\n  /**\n   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.\n   */\n  accelerateUrl: string\n  adapter?: never\n}) & {\n  /**\n   * @default \"colorless\"\n   */\n  errorFormat?: ErrorFormat\n  /**\n   * @example\n   * ```\n   * // Shorthand for `emit: 'stdout'`\n   * log: ['query', 'info', 'warn', 'error']\n   * \n   * // Emit as events only\n   * log: [\n   *   { emit: 'event', level: 'query' },\n   *   { emit: 'event', level: 'info' },\n   *   { emit: 'event', level: 'warn' }\n   *   { emit: 'event', level: 'error' }\n   * ]\n   * \n   * / Emit as events and log to stdout\n   * og: [\n   *  { emit: 'stdout', level: 'query' },\n   *  { emit: 'stdout', level: 'info' },\n   *  { emit: 'stdout', level: 'warn' }\n   *  { emit: 'stdout', level: 'error' }\n   * \n   * ```\n   * Read more in our [docs](https://pris.ly/d/logging).\n   */\n  log?: (LogLevel | LogDefinition)[]\n  /**\n   * The default values for transactionOptions\n   * maxWait ?= 2000\n   * timeout ?= 5000\n   */\n  transactionOptions?: {\n    maxWait?: number\n    timeout?: number\n    isolationLevel?: TransactionIsolationLevel\n  }\n  /**\n   * Global configuration for omitting model fields by default.\n   * \n   * @example\n   * ```\n   * const prisma = new PrismaClient({\n   *   omit: {\n   *     user: {\n   *       password: true\n   *     }\n   *   }\n   * })\n   * ```\n   */\n  omit?: GlobalOmitConfig\n  /**\n   * SQL commenter plugins that add metadata to SQL queries as comments.\n   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/\n   * \n   * @example\n   * ```\n   * const prisma = new PrismaClient({\n   *   adapter,\n   *   comments: [\n   *     traceContext(),\n   *     queryInsights(),\n   *   ],\n   * })\n   * ```\n   */\n  comments?: runtime.SqlCommenterPlugin[]\n}\nexport type GlobalOmitConfig = {\n  all_ingredients?: Prisma.all_ingredientsOmit\n  instructions?: Prisma.instructionsOmit\n  recipe_ingredients?: Prisma.recipe_ingredientsOmit\n  recipes?: Prisma.recipesOmit\n  account?: Prisma.accountOmit\n  invitation?: Prisma.invitationOmit\n  jwks?: Prisma.jwksOmit\n  member?: Prisma.memberOmit\n  organization?: Prisma.organizationOmit\n  project_config?: Prisma.project_configOmit\n  session?: Prisma.sessionOmit\n  user?: Prisma.userOmit\n  verification?: Prisma.verificationOmit\n}\n\n/* Types for Logging */\nexport type LogLevel = 'info' | 'query' | 'warn' | 'error'\nexport type LogDefinition = {\n  level: LogLevel\n  emit: 'stdout' | 'event'\n}\n\nexport type CheckIsLogLevel<T> = T extends LogLevel ? T : never;\n\nexport type GetLogType<T> = CheckIsLogLevel<\n  T extends LogDefinition ? T['level'] : T\n>;\n\nexport type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>\n  ? GetLogType<T[number]>\n  : never;\n\nexport type QueryEvent = {\n  timestamp: Date\n  query: string\n  params: string\n  duration: number\n  target: string\n}\n\nexport type LogEvent = {\n  timestamp: Date\n  message: string\n  target: string\n}\n/* End Types for Logging */\n\n\nexport type PrismaAction =\n  | 'findUnique'\n  | 'findUniqueOrThrow'\n  | 'findMany'\n  | 'findFirst'\n  | 'findFirstOrThrow'\n  | 'create'\n  | 'createMany'\n  | 'createManyAndReturn'\n  | 'update'\n  | 'updateMany'\n  | 'updateManyAndReturn'\n  | 'upsert'\n  | 'delete'\n  | 'deleteMany'\n  | 'executeRaw'\n  | 'queryRaw'\n  | 'aggregate'\n  | 'count'\n  | 'runCommandRaw'\n  | 'findRaw'\n  | 'groupBy'\n\n/**\n * `PrismaClient` proxy available in interactive transactions.\n */\nexport type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>\n\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;;;;;;;CAUC,GAED;;AAcO,MAAM,gCAAgC,iQAAqC;AAG3E,MAAM,kCAAkC,mQAAuC;AAG/E,MAAM,6BAA6B,8PAAkC;AAGrE,MAAM,kCAAkC,mQAAuC;AAG/E,MAAM,8BAA8B,+PAAmC;AAMvE,MAAM,MAAM,0OAAc;AAC1B,MAAM,QAAQ,yOAAa;AAC3B,MAAM,OAAO,wOAAY;AACzB,MAAM,MAAM,uOAAW;AACvB,MAAM,MAAM,uOAAW;AAQvB,MAAM,UAAU,2OAAe;AAS/B,MAAM,sBAAsB,8OAAkB,CAAC,mBAAmB;AAelE,MAAM,gBAA+B;IAC1C,QAAQ;IACR,QAAQ;AACV;AAeO,MAAM,YAAY;IACvB,QAAQ,6OAAiB,CAAC,MAAM;IAChC,UAAU,6OAAiB,CAAC,QAAQ;IACpC,SAAS,6OAAiB,CAAC,OAAO;AACpC;AAMO,MAAM,SAAS,0OAAc;AAO7B,MAAM,WAAW,4OAAgB;AAOjC,MAAM,UAAU,2OAAe;AAkQ/B,MAAM,YAAY;IACvB,iBAAiB;IACjB,cAAc;IACd,oBAAoB;IACpB,SAAS;IACT,SAAS;IACT,YAAY;IACZ,MAAM;IACN,QAAQ;IACR,cAAc;IACd,gBAAgB;IAChB,SAAS;IACT,MAAM;IACN,cAAc;AAChB;AAk/BO,MAAM,4BAA4B,kPAAsB,CAAC;IAC9D,iBAAiB;IACjB,eAAe;IACf,gBAAgB;IAChB,cAAc;AAChB;AAKO,MAAM,iCAAiC;IAC5C,IAAI;IACJ,YAAY;IACZ,MAAM;IACN,MAAM;AACR;AAKO,MAAM,8BAA8B;IACzC,IAAI;IACJ,YAAY;IACZ,WAAW;IACX,oBAAoB;IACpB,kBAAkB;AACpB;AAKO,MAAM,oCAAoC;IAC/C,IAAI;IACJ,YAAY;IACZ,eAAe;IACf,QAAQ;IACR,WAAW;IACX,kBAAkB;IAClB,gBAAgB;AAClB;AAKO,MAAM,yBAAyB;IACpC,IAAI;IACJ,YAAY;IACZ,OAAO;IACP,WAAW;IACX,WAAW;IACX,WAAW;IACX,UAAU;AACZ;AAKO,MAAM,yBAAyB;IACpC,IAAI;IACJ,WAAW;IACX,YAAY;IACZ,QAAQ;IACR,aAAa;IACb,cAAc;IACd,SAAS;IACT,sBAAsB;IACtB,uBAAuB;IACvB,OAAO;IACP,UAAU;IACV,WAAW;IACX,WAAW;AACb;AAKO,MAAM,4BAA4B;IACvC,IAAI;IACJ,gBAAgB;IAChB,OAAO;IACP,MAAM;IACN,QAAQ;IACR,WAAW;IACX,WAAW;IACX,WAAW;AACb;AAKO,MAAM,sBAAsB;IACjC,IAAI;IACJ,WAAW;IACX,YAAY;IACZ,WAAW;IACX,WAAW;AACb;AAKO,MAAM,wBAAwB;IACnC,IAAI;IACJ,gBAAgB;IAChB,QAAQ;IACR,MAAM;IACN,WAAW;AACb;AAKO,MAAM,8BAA8B;IACzC,IAAI;IACJ,MAAM;IACN,MAAM;IACN,MAAM;IACN,WAAW;IACX,UAAU;AACZ;AAKO,MAAM,gCAAgC;IAC3C,IAAI;IACJ,MAAM;IACN,aAAa;IACb,YAAY;IACZ,YAAY;IACZ,iBAAiB;IACjB,kBAAkB;IAClB,gBAAgB;IAChB,oBAAoB;IACpB,iBAAiB;AACnB;AAKO,MAAM,yBAAyB;IACpC,IAAI;IACJ,WAAW;IACX,OAAO;IACP,WAAW;IACX,WAAW;IACX,WAAW;IACX,WAAW;IACX,QAAQ;IACR,gBAAgB;IAChB,sBAAsB;AACxB;AAKO,MAAM,sBAAsB;IACjC,IAAI;IACJ,MAAM;IACN,OAAO;IACP,eAAe;IACf,OAAO;IACP,WAAW;IACX,WAAW;IACX,MAAM;IACN,QAAQ;IACR,WAAW;IACX,YAAY;AACd;AAKO,MAAM,8BAA8B;IACzC,IAAI;IACJ,YAAY;IACZ,OAAO;IACP,WAAW;IACX,WAAW;IACX,WAAW;AACb;AAKO,MAAM,YAAY;IACvB,KAAK;IACL,MAAM;AACR;AAKO,MAAM,qBAAqB;IAChC,UAAU;AACZ;AAKO,MAAM,6BAA6B;IACxC,QAAQ;IACR,UAAU;AACZ;AAKO,MAAM,YAAY;IACvB,SAAS;IACT,aAAa;AACf;AAKO,MAAM,aAAa;IACxB,OAAO;IACP,MAAM;AACR;AAKO,MAAM,sBAAsB;IACjC,QAAQ;IACR,UAAU;IACV,SAAS;AACX;AAgMO,MAAM,kBAAkB,8OAAkB,CAAC,eAAe"}},
    {"offset": {"line": 364, "column": 0}, "map": {"version":3,"sources":["file:///C:/Git/Senior%20Project/RecipeWebsite/src/generated/prisma/enums.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n* This file exports all enum related types from the schema.\n*\n* ðŸŸ¢ You can import this file directly.\n*/\n\nexport const cook_time = {\n  MIN_10: 'MIN_10',\n  MIN_20: 'MIN_20',\n  MIN_30: 'MIN_30',\n  MIN_40: 'MIN_40',\n  MIN_50: 'MIN_50',\n  MIN_60: 'MIN_60',\n  MIN_00: 'MIN_00'\n} as const\n\nexport type cook_time = (typeof cook_time)[keyof typeof cook_time]\n\n\nexport const fractions = {\n  F_1_16: 'F_1_16',\n  F_1_8: 'F_1_8',\n  F_3_16: 'F_3_16',\n  F_1_4: 'F_1_4',\n  F_5_16: 'F_5_16',\n  F_1_3: 'F_1_3',\n  F_3_8: 'F_3_8',\n  F_7_16: 'F_7_16',\n  F_1_2: 'F_1_2',\n  F_9_16: 'F_9_16',\n  F_5_8: 'F_5_8',\n  F_2_3: 'F_2_3',\n  F_11_16: 'F_11_16',\n  F_3_4: 'F_3_4',\n  F_13_16: 'F_13_16',\n  F_7_8: 'F_7_8',\n  F_15_16: 'F_15_16'\n} as const\n\nexport type fractions = (typeof fractions)[keyof typeof fractions]\n\n\nexport const ingredient_type = {\n  Grains___Legumes: 'Grains___Legumes',\n  Produce__Fresh_: 'Produce__Fresh_',\n  Dairy___Refrigerated: 'Dairy___Refrigerated',\n  Proteins: 'Proteins',\n  Pantry_Staples: 'Pantry_Staples',\n  Spices___Seasonings: 'Spices___Seasonings'\n} as const\n\nexport type ingredient_type = (typeof ingredient_type)[keyof typeof ingredient_type]\n\n\nexport const meal_type = {\n  Breakfast: 'Breakfast',\n  Lunch: 'Lunch',\n  Dinner: 'Dinner',\n  Dessert: 'Dessert',\n  Drink: 'Drink',\n  Snack: 'Snack'\n} as const\n\nexport type meal_type = (typeof meal_type)[keyof typeof meal_type]\n\n\nexport const measurement_type = {\n  Cups: 'Cups',\n  Teaspoons: 'Teaspoons',\n  Tablespoons: 'Tablespoons',\n  Fluid: 'Fluid',\n  Ounces: 'Ounces',\n  Pounds: 'Pounds',\n  None_: 'None_',\n  Grams: 'Grams',\n  Kilograms: 'Kilograms',\n  Milliliters: 'Milliliters'\n} as const\n\nexport type measurement_type = (typeof measurement_type)[keyof typeof measurement_type]\n\n\nexport const prep_time = {\n  MIN_10: 'MIN_10',\n  MIN_20: 'MIN_20',\n  MIN_30: 'MIN_30',\n  MIN_40: 'MIN_40',\n  MIN_50: 'MIN_50',\n  MIN_60: 'MIN_60',\n  MIN_00: 'MIN_00'\n} as const\n\nexport type prep_time = (typeof prep_time)[keyof typeof prep_time]\n"],"names":[],"mappings":"AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;AAIA;;;;;;;;;;;;;;AAEO,MAAM,YAAY;IACvB,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;AACV;AAKO,MAAM,YAAY;IACvB,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,OAAO;IACP,OAAO;IACP,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,OAAO;IACP,OAAO;IACP,SAAS;IACT,OAAO;IACP,SAAS;IACT,OAAO;IACP,SAAS;AACX;AAKO,MAAM,kBAAkB;IAC7B,kBAAkB;IAClB,iBAAiB;IACjB,sBAAsB;IACtB,UAAU;IACV,gBAAgB;IAChB,qBAAqB;AACvB;AAKO,MAAM,YAAY;IACvB,WAAW;IACX,OAAO;IACP,QAAQ;IACR,SAAS;IACT,OAAO;IACP,OAAO;AACT;AAKO,MAAM,mBAAmB;IAC9B,MAAM;IACN,WAAW;IACX,aAAa;IACb,OAAO;IACP,QAAQ;IACR,QAAQ;IACR,OAAO;IACP,OAAO;IACP,WAAW;IACX,aAAa;AACf;AAKO,MAAM,YAAY;IACvB,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;AACV"}},
    {"offset": {"line": 453, "column": 0}, "map": {"version":3,"sources":["file:///C:/Git/Senior%20Project/RecipeWebsite/src/generated/prisma/client.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * This file should be your main import to use Prisma. Through it you get access to all the models, enums, and input types.\n * If you're looking for something you can import in the client-side of your application, please refer to the `browser.ts` file instead.\n *\n * ðŸŸ¢ You can import this file directly.\n */\n\nimport * as process from 'node:process'\nimport * as path from 'node:path'\nimport { fileURLToPath } from 'node:url'\nglobalThis['__dirname'] = path.dirname(fileURLToPath(import.meta.url))\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport * as $Enums from \"./enums\"\nimport * as $Class from \"./internal/class\"\nimport * as Prisma from \"./internal/prismaNamespace\"\n\nexport * as $Enums from './enums'\nexport * from \"./enums\"\n/**\n * ## Prisma Client\n * \n * Type-safe database client for TypeScript\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more All_ingredients\n * const all_ingredients = await prisma.all_ingredients.findMany()\n * ```\n * \n * Read more in our [docs](https://pris.ly/d/client).\n */\nexport const PrismaClient = $Class.getPrismaClientClass()\nexport type PrismaClient<LogOpts extends Prisma.LogLevel = never, OmitOpts extends Prisma.PrismaClientOptions[\"omit\"] = Prisma.PrismaClientOptions[\"omit\"], ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $Class.PrismaClient<LogOpts, OmitOpts, ExtArgs>\nexport { Prisma }\n\n/**\n * Model all_ingredients\n * \n */\nexport type all_ingredients = Prisma.all_ingredientsModel\n/**\n * Model instructions\n * \n */\nexport type instructions = Prisma.instructionsModel\n/**\n * Model recipe_ingredients\n * \n */\nexport type recipe_ingredients = Prisma.recipe_ingredientsModel\n/**\n * Model recipes\n * \n */\nexport type recipes = Prisma.recipesModel\n/**\n * Model account\n * \n */\nexport type account = Prisma.accountModel\n/**\n * Model invitation\n * \n */\nexport type invitation = Prisma.invitationModel\n/**\n * Model jwks\n * \n */\nexport type jwks = Prisma.jwksModel\n/**\n * Model member\n * \n */\nexport type member = Prisma.memberModel\n/**\n * Model organization\n * \n */\nexport type organization = Prisma.organizationModel\n/**\n * Model project_config\n * \n */\nexport type project_config = Prisma.project_configModel\n/**\n * Model session\n * \n */\nexport type session = Prisma.sessionModel\n/**\n * Model user\n * \n */\nexport type user = Prisma.userModel\n/**\n * Model verification\n * \n */\nexport type verification = Prisma.verificationModel\n"],"names":[],"mappings":"AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;;CAKC;;;;AAGD;AACA;AAKA;AACA;AAEA;;;;;;;;AAPA,UAAU,CAAC,YAAY,GAAG,4HAAY,CAAC,IAAA,gIAAa,EAAC,8BAAY,GAAG;;;;;AAsB7D,MAAM,eAAe,uKAA2B"}},
    {"offset": {"line": 489, "column": 0}, "map": {"version":3,"sources":["file:///C:/Git/Senior%20Project/RecipeWebsite/src/lib/prisma.js"],"sourcesContent":["import { PrismaClient } from '../generated/prisma/client';\r\nimport { PrismaPg } from '@prisma/adapter-pg';\r\nimport pg from 'pg';\r\n\r\nconst globalForPrisma = global;\r\n\r\nconst connectionString = process.env.DATABASE_URL;\r\nconst pool = new pg.Pool({ connectionString });\r\nconst adapter = new PrismaPg(pool);\r\n\r\nexport const prisma =\r\n  globalForPrisma.prisma ||\r\n  new PrismaClient({\r\n    adapter: adapter, // This is the crucial missing piece\r\n  });\r\n\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;;;;;;AAEA,MAAM;AAEN,MAAM,mBAAmB,QAAQ,GAAG,CAAC,YAAY;AACjD,MAAM,OAAO,IAAI,wJAAE,CAAC,IAAI,CAAC;IAAE;AAAiB;AAC5C,MAAM,UAAU,IAAI,uKAAQ,CAAC;AAEtB,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,oKAAY,CAAC;IACf,SAAS;AACX;AAEF,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 519, "column": 0}, "map": {"version":3,"sources":["file:///C:/Git/Senior%20Project/RecipeWebsite/src/app/finder/RecipeFinderClient.js/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/finder/RecipeFinderClient.js <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/finder/RecipeFinderClient.js <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;;AAAA,uEAAuE;AACvE;;uCACe,IAAA,wQAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAAwS,GACrU,sEACA","ignoreList":[0]}},
    {"offset": {"line": 533, "column": 0}, "map": {"version":3,"sources":["file:///C:/Git/Senior%20Project/RecipeWebsite/src/app/finder/RecipeFinderClient.js/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/finder/RecipeFinderClient.js from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/finder/RecipeFinderClient.js\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;;AAAA,uEAAuE;AACvE;;uCACe,IAAA,wQAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAAoR,GACjT,kDACA","ignoreList":[0]}},
    {"offset": {"line": 547, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 557, "column": 0}, "map": {"version":3,"sources":["file:///C:/Git/Senior%20Project/RecipeWebsite/src/app/finder/page.js"],"sourcesContent":["// app/recipe-finder/page.js\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport RecipeFinderClient from \"./RecipeFinderClient\";\r\n\r\nexport default async function RecipeFinderPage() {\r\n  // 1. Fetch random recipes\r\n  const rawRecipes = await prisma.$queryRaw`\r\n    SELECT * FROM \"recipe_management\".\"recipes\" ORDER BY RANDOM() LIMIT 15\r\n  `;\r\n\r\n  // 2. IMPORTANT: Serialize the data\r\n  // This converts Decimals to Strings and ensures the array is clean\r\n  // and compatible with the \"use client\" component.\r\n  const initialRecipes = JSON.parse(JSON.stringify(rawRecipes));\r\n\r\n  return (\r\n    <main className=\"p-8\">\r\n      {/* 3. Add a fallback to prevent \"undefined\" errors in the client */}\r\n      <RecipeFinderClient initialRecipes={initialRecipes || []} />\r\n    </main>\r\n  );\r\n}"],"names":[],"mappings":";;;;;AAAA,4BAA4B;AAC5B;AACA;;;;;;;;AAEe,eAAe;IAC5B,0BAA0B;IAC1B,MAAM,aAAa,MAAM,8HAAM,CAAC,SAAS,CAAC;;EAE1C,CAAC;IAED,mCAAmC;IACnC,mEAAmE;IACnE,kDAAkD;IAClD,MAAM,iBAAiB,KAAK,KAAK,CAAC,KAAK,SAAS,CAAC;IAEjD,qBACE,8OAAC;QAAK,WAAU;kBAEd,cAAA,8OAAC,qJAAkB;YAAC,gBAAgB,kBAAkB,EAAE;;;;;;;;;;;AAG9D"}}]
}